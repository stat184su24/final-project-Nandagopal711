---
title: "Final Project"
author: "Nandagopal Panicker"
output: html_notebook
---


## Research Objective 

The aim of this project is to successfully compare two datasets to derive valuable insights from both of them. I have a couple of objectives in mind with regards to spotting trends:

* I want to find the top 5 songs appearing the most in playlists in 2023 and 2024 and make a vizualization revolving around the same.

* Since this is not a key feature in the 2024 dataset, I want to see if the bpm of a song has a correlation of sorts to how popular it is on the most popular streaming platform(Spotify).

* In addition to this, I want to compare the streams for songs over Spotify, Deezer, and Apple Music and see if the music in 2024 is more popular than the music in 2023.


## Data Processing 

#### Data Intake 

A couple of things are important to note with regards to these data-sets. The 2023 spotify dataset has a lot less data than the 2024 one.

Both these datasets have been provided by the Spotify API. For the sake of visualization and data preprocessing steps, we will take only the top 50 songs of each year of each dataset.

I have downloaded the two datasets from Kaggle, they are publicly available datasets with the links as follows:

[Click here for the link to the 2023 Spotify Dataset](https://www.kaggle.com/datasets/nelgiriyewithana/top-spotify-songs-2023)

[Click here for the link to the 2024 Spotify Dataset](https://www.kaggle.com/datasets/nelgiriyewithana/most-streamed-spotify-songs-2024?resource=download)


I have uploaded the csv files on the 'Final Project' Git repository, and pulled the files onto my local workspace.


#### Data Wrangling 

Include R code and written explanation for wangling your data (you can make multiple wrangled data sets). 

```{r}
library(tidyverse)
data2023 <- read.csv("spotify-2023.csv")
head(data1)
```
This is the head of the 2023 Spotify Most Streamed Charts.

```{r}
data2024 <- read.csv("Most Streamed Spotify Songs 2024.csv")
head(data2024)
```
This is the head of the Spotify 2024 most streamed charts.


Next, it is important for us to use some kind of imputational model normally with regards to data cleaning for handling of missing values. I am not too familiar with the use of imputational models on R, instead, since the datasets are so vast, we can find rows with missing values for each data set and remove them from our data-sets. 

```{r}
sum(is.na(data2023)) # Checking for rows with missing values in 2023 Spotify Dataset 
```
As it turns out there are no missing values in this data-set, but for the sake of safety, we can remove any if at all:
```{r}
data2023 <- na.omit(data2023)
sum(is.na(data2023))
```
For data cleaning, it is important to note that while this is not the case for 2023, in 2024 a lot of variables are in string format, we will change them to numerical values accordingly for better help with regards to visualization:

```{r}
data2024 <- data2024 %>%
  mutate(
    Spotify.Streams = as.numeric(gsub(",", "", Spotify.Streams)),
    Spotify.Playlist.Count = as.numeric(gsub(",", "", Spotify.Playlist.Count)),
    Spotify.Playlist.Reach = as.numeric(gsub(",", "", Spotify.Playlist.Reach)),
    YouTube.Views = as.numeric(gsub(",", "", YouTube.Views)),
    YouTube.Likes = as.numeric(gsub(",", "", YouTube.Likes)),
    TikTok.Posts = as.numeric(gsub(",", "", TikTok.Posts)),
    TikTok.Likes = as.numeric(gsub(",", "", TikTok.Likes)),
    TikTok.Views = as.numeric(gsub(",", "", TikTok.Views)),
    YouTube.Playlist.Reach = as.numeric(gsub(",", "", YouTube.Playlist.Reach)),
    Apple.Music.Playlist.Count = as.numeric(Apple.Music.Playlist.Count),
    Deezer.Playlist.Count = as.numeric(Deezer.Playlist.Count),
    Deezer.Playlist.Reach = as.numeric(gsub(",", "", Deezer.Playlist.Reach)),
    Amazon.Playlist.Count = as.numeric(Amazon.Playlist.Count),
    Pandora.Streams = as.numeric(gsub(",", "", Pandora.Streams)),
    Pandora.Track.Stations = as.numeric(gsub(",", "", Pandora.Track.Stations)),
    Soundcloud.Streams = as.numeric(gsub(",", "", Soundcloud.Streams)),
    Shazam.Counts = as.numeric(gsub(",", "", Shazam.Counts))
  )
```


We can now perform the same check for the 2024 Data-set.

```{r}
sum(is.na(data2024)) # Checking for rows with missing values in 2024 Spotify Dataset 
```
There seem to be 25759 rows with missing information. This is expected since it is a much larger dataset than that of the 2023. We must now fill in these rows and check again:

```{r}
library(tidyverse)
data2024[is.na(data2024)] <- 0
sum(is.na(data2024))
```
Instead of ommitting these rows since a very large number of observations seem to be left out, we have just replaced the N/A's with a value of 0 thus retaining the dataset, since no observation was left if we tried to omit all rows with missing values. Another imputational model could have been employed by calculating the mean or median of columns but for the sake of simplicity, I assigned 0.


Let us continue with the data wrangling methods now that we have gotten a better understanding of our dataset.


For the first part of our objective, we need to find the top 5 songs appearing the most in spotify playlists in 2023 and 2024 respectively:


* In 2023:

```{r}
top5_2023 <- data2023 %>%
  arrange(desc(in_spotify_playlists)) %>%
  slice_head(n = 5)

top5_2023
```

* In 2024:

```{r}
top5_2024 <- data2024 %>%
  arrange(desc(Spotify.Playlist.Count)) %>%
  slice_head(n = 5)

top5_2024
```

Computing Correlation between bpm and popularity(2023:


```{r}
non_numeric_streams <- data2023 %>%
  filter(!is.na(streams) & !grepl("^\\d+$", gsub(",", "", streams)))

data2023_cleaned <- data2023 %>%
  mutate(
    bpm = as.numeric(bpm),
    streams = as.numeric(gsub(",", "", streams))
  ) %>%
  filter(!is.na(bpm) & !is.na(streams))

mean_bpm_2023 <- mean(data2023_cleaned$bpm)
mean_streams_2023 <- mean(data2023_cleaned$streams)
cov_2023 <- mean((data2023_cleaned$bpm - mean_bpm_2023) * (data2023_cleaned$streams - mean_streams_2023))
sd_bpm_2023 <- sd(data2023_cleaned$bpm)
sd_streams_2023 <- sd(data2023_cleaned$streams)
correlation_bpm_streams_2023 <- cov_2023 / (sd_bpm_2023 * sd_streams_2023)

print(paste("Pearson correlation for 2023:", correlation_bpm_streams_2023))

```
Therefore, we can see the pearson correlation coeff is -0.002. 


## Data Visualization

Now, we have to visualize the Data we have wrangled.

Top 5 most popular playlist songs in 2023 and 2024:


In 2023, the 5 most popular songs in playlists were:

```{r}
library(ggplot2)

ggplot(top5_2023, aes(x = track_name, y = in_spotify_playlists)) +
  geom_bar(stat = "identity", fill = "blue") +
  coord_flip() +
  labs(title = "Top 5 Songs in Spotify Playlists (2023)",
       x = "Track Name",
       y = "Number of Playlists") +
  theme_minimal()

```
In 2024, the 5 most popular songs in playlists were:

```{r}
ggplot(top5_2024, aes(x = Track, y = Spotify.Playlist.Count)) +
  geom_bar(stat = "identity", fill = "green") +
  coord_flip() +
  labs(title = "Top 5 Songs in Spotify Playlists (2024)",
       x = "Track Name",
       y = "Number of Playlists") +
  theme_minimal()
```


Visualization for correlation between bpm and popularity in 2023:

```{r}
ggplot(data2023_cleaned, aes(x = bpm, y = streams)) +
  geom_point(color = "blue") +
  geom_line(color = "green") +
  labs(title = "BPM vs. Streams (2023)",
       x = "BPM",
       y = "Streams") +
  theme_minimal()
```



## Conclusion

The 5 most popular songs in the 2023 playlist were(in increasing order of playlist presence):

i) Take on me
ii) Smells Like Teen Spirit - Remastered 2021
iii) Wake Me Up - Radio Edit
iv) Mr. Brightside
v) Get Lucky - Radio Edit

The 5 most popular songs in the 2024 playlist were(in increasing order of playlist presence):

i) Smells Like Teen Spirit
ii) Sweater Weather
iii) STAY(with Justin Bieber)
iv) Heat Waves
v) Blinding Lights


With regards to the BPM Vs Streams Correlation: 

There seems to be a slightly negative correlation between BPM and Popularity of Songs, and the graph reflects that there is no correlation that proves that the higher the BPM of a song.




